## API Report File for "@rushstack/node-core-library"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import * as child_process from 'child_process';
import * as fs from 'fs';

// @public
export enum AlreadyExistsBehavior {
    Error = "error",
    Ignore = "ignore",
    Overwrite = "overwrite"
}

// @public
export class AlreadyReportedError extends Error {
    // (undocumented)
    static [Symbol.hasInstance](instance: object): boolean;
    constructor();
}

// @public
export class AnsiEscape {
    static formatForTests(text: string, options?: IAnsiEscapeConvertForTestsOptions): string;
    static removeCodes(text: string): string;
}

// @beta
export class Async {
    static forEachAsync<TEntry>(iterable: Iterable<TEntry> | AsyncIterable<TEntry>, callback: (entry: TEntry, arrayIndex: number) => Promise<void>, options?: IAsyncParallelismOptions | undefined): Promise<void>;
    static mapAsync<TEntry, TRetVal>(iterable: Iterable<TEntry> | AsyncIterable<TEntry>, callback: (entry: TEntry, arrayIndex: number) => Promise<TRetVal>, options?: IAsyncParallelismOptions | undefined): Promise<TRetVal[]>;
    static sleep(ms: number): Promise<void>;
}

// @public
export type Brand<T, BrandTag extends string> = T & {
    __brand: BrandTag;
};

// @beta
export class Colors {
    // (undocumented)
    static black(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static blackBackground(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static blink(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static blue(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static blueBackground(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static bold(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static cyan(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static cyanBackground(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static dim(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static gray(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static grayBackground(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static green(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static greenBackground(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static hidden(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static invertColor(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static magenta(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static magentaBackground(text: string | IColorableSequence): IColorableSequence;
    // @internal
    static _normalizeStringOrColorableSequence(value: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static red(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static redBackground(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static underline(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static white(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static whiteBackground(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static yellow(text: string | IColorableSequence): IColorableSequence;
    // (undocumented)
    static yellowBackground(text: string | IColorableSequence): IColorableSequence;
}

// @beta
export enum ColorValue {
    // (undocumented)
    Black = 0,
    // (undocumented)
    Blue = 4,
    // (undocumented)
    Cyan = 6,
    // (undocumented)
    Gray = 8,
    // (undocumented)
    Green = 2,
    // (undocumented)
    Magenta = 5,
    // (undocumented)
    Red = 1,
    // (undocumented)
    White = 7,
    // (undocumented)
    Yellow = 3
}

// @beta
export class ConsoleTerminalProvider implements ITerminalProvider {
    constructor(options?: Partial<IConsoleTerminalProviderOptions>);
    debugEnabled: boolean;
    get eolCharacter(): string;
    get supportsColor(): boolean;
    verboseEnabled: boolean;
    write(data: string, severity: TerminalProviderSeverity): void;
}

// @public
export enum Encoding {
    // (undocumented)
    Utf8 = "utf8"
}

// @public
export class Enum {
    static getKeyByNumber<TEnumValue, TEnumObject extends {
        [key: string]: TEnumValue;
    }>(enumObject: TEnumObject, value: number): keyof typeof enumObject;
    static getValueByKey<TEnumValue>(enumObject: {
        [key: string]: TEnumValue | string;
        [key: number]: TEnumValue | string;
    }, key: string): TEnumValue;
    static tryGetKeyByNumber<TEnumValue, TEnumObject extends {
        [key: string]: TEnumValue;
    }>(enumObject: TEnumObject, value: number): keyof typeof enumObject | undefined;
    static tryGetValueByKey<TEnumValue>(enumObject: {
        [key: string]: TEnumValue | string;
        [key: number]: TEnumValue | string;
    }, key: string): TEnumValue | undefined;
}

// @public
export class EnvironmentMap {
    constructor(environmentObject?: Record<string, string | undefined>);
    readonly caseSensitive: boolean;
    clear(): void;
    entries(): IterableIterator<IEnvironmentEntry>;
    get(name: string): string | undefined;
    mergeFrom(environmentMap: EnvironmentMap): void;
    mergeFromObject(environmentObject?: Record<string, string | undefined>): void;
    names(): IterableIterator<string>;
    set(name: string, value: string): void;
    toObject(): Record<string, string>;
    unset(name: string): void;
}

// @public
export class Executable {
    static spawn(filename: string, args: string[], options?: IExecutableSpawnOptions): child_process.ChildProcess;
    static spawnSync(filename: string, args: string[], options?: IExecutableSpawnSyncOptions): child_process.SpawnSyncReturns<string>;
    static tryResolve(filename: string, options?: IExecutableResolveOptions): string | undefined;
}

// @public
export type ExecutableStdioMapping = 'pipe' | 'ignore' | 'inherit' | ExecutableStdioStreamMapping[];

// @public
export type ExecutableStdioStreamMapping = 'pipe' | 'ignore' | 'inherit' | NodeJS.WritableStream | NodeJS.ReadableStream | number | undefined;

// @public
export enum FileConstants {
    PackageJson = "package.json"
}

// @public
export class FileError extends Error {
    // (undocumented)
    static [Symbol.hasInstance](instance: object): boolean;
    constructor(message: string, options: IFileErrorOptions);
    readonly absolutePath: string;
    readonly column: number | undefined;
    // @internal (undocumented)
    static _environmentVariableIsAbsolutePath: boolean;
    getFormattedErrorMessage(options?: IFileErrorFormattingOptions): string;
    readonly line: number | undefined;
    readonly projectFolder: string;
    // @internal (undocumented)
    static _sanitizedEnvironmentVariable: string | undefined;
    // @override
    toString(): string;
}

// @public
export type FileLocationStyle = 'Unix' | 'VisualStudio';

// @public
export class FileSystem {
    static appendToFile(filePath: string, contents: string | Buffer, options?: IFileSystemWriteFileOptions): void;
    static appendToFileAsync(filePath: string, contents: string | Buffer, options?: IFileSystemWriteFileOptions): Promise<void>;
    static changePosixModeBits(path: string, mode: PosixModeBits): void;
    static changePosixModeBitsAsync(path: string, mode: PosixModeBits): Promise<void>;
    static copyFile(options: IFileSystemCopyFileOptions): void;
    static copyFileAsync(options: IFileSystemCopyFileOptions): Promise<void>;
    static copyFiles(options: IFileSystemCopyFilesOptions): void;
    static copyFilesAsync(options: IFileSystemCopyFilesOptions): Promise<void>;
    static createHardLink(options: IFileSystemCreateLinkOptions): void;
    static createHardLinkAsync(options: IFileSystemCreateLinkOptions): Promise<void>;
    static createSymbolicLinkFile(options: IFileSystemCreateLinkOptions): void;
    static createSymbolicLinkFileAsync(options: IFileSystemCreateLinkOptions): Promise<void>;
    static createSymbolicLinkFolder(options: IFileSystemCreateLinkOptions): void;
    static createSymbolicLinkFolderAsync(options: IFileSystemCreateLinkOptions): Promise<void>;
    static createSymbolicLinkJunction(options: IFileSystemCreateLinkOptions): void;
    static createSymbolicLinkJunctionAsync(options: IFileSystemCreateLinkOptions): Promise<void>;
    static deleteFile(filePath: string, options?: IFileSystemDeleteFileOptions): void;
    static deleteFileAsync(filePath: string, options?: IFileSystemDeleteFileOptions): Promise<void>;
    static deleteFolder(folderPath: string): void;
    static deleteFolderAsync(folderPath: string): Promise<void>;
    static ensureEmptyFolder(folderPath: string): void;
    static ensureEmptyFolderAsync(folderPath: string): Promise<void>;
    static ensureFolder(folderPath: string): void;
    static ensureFolderAsync(folderPath: string): Promise<void>;
    static exists(path: string): boolean;
    static existsAsync(path: string): Promise<boolean>;
    static formatPosixModeBits(modeBits: PosixModeBits): string;
    static getLinkStatistics(path: string): FileSystemStats;
    static getLinkStatisticsAsync(path: string): Promise<FileSystemStats>;
    static getPosixModeBits(path: string): PosixModeBits;
    static getPosixModeBitsAsync(path: string): Promise<PosixModeBits>;
    static getRealPath(linkPath: string): string;
    static getRealPathAsync(linkPath: string): Promise<string>;
    static getStatistics(path: string): FileSystemStats;
    static getStatisticsAsync(path: string): Promise<FileSystemStats>;
    static isDirectoryError(error: Error): boolean;
    static isErrnoException(error: Error): error is NodeJS.ErrnoException;
    static isExistError(error: Error): boolean;
    static isFileDoesNotExistError(error: Error): boolean;
    static isFolderDoesNotExistError(error: Error): boolean;
    static isNotExistError(error: Error): boolean;
    static isUnlinkNotPermittedError(error: Error): boolean;
    static move(options: IFileSystemMoveOptions): void;
    static moveAsync(options: IFileSystemMoveOptions): Promise<void>;
    static readFile(filePath: string, options?: IFileSystemReadFileOptions): string;
    static readFileAsync(filePath: string, options?: IFileSystemReadFileOptions): Promise<string>;
    static readFileToBuffer(filePath: string): Buffer;
    static readFileToBufferAsync(filePath: string): Promise<Buffer>;
    // @deprecated (undocumented)
    static readFolder(folderPath: string, options?: IFileSystemReadFolderOptions): string[];
    // @deprecated (undocumented)
    static readFolderAsync(folderPath: string, options?: IFileSystemReadFolderOptions): Promise<string[]>;
    static readFolderItemNames(folderPath: string, options?: IFileSystemReadFolderOptions): string[];
    static readFolderItemNamesAsync(folderPath: string, options?: IFileSystemReadFolderOptions): Promise<string[]>;
    static readFolderItems(folderPath: string, options?: IFileSystemReadFolderOptions): FolderItem[];
    static readFolderItemsAsync(folderPath: string, options?: IFileSystemReadFolderOptions): Promise<FolderItem[]>;
    static readLink(path: string): string;
    static readLinkAsync(path: string): Promise<string>;
    static updateTimes(path: string, times: IFileSystemUpdateTimeParameters): void;
    static updateTimesAsync(path: string, times: IFileSystemUpdateTimeParameters): Promise<void>;
    static writeFile(filePath: string, contents: string | Buffer, options?: IFileSystemWriteFileOptions): void;
    static writeFileAsync(filePath: string, contents: string | Buffer, options?: IFileSystemWriteFileOptions): Promise<void>;
}

// @public
export type FileSystemCopyFilesAsyncFilter = (sourcePath: string, destinationPath: string) => Promise<boolean>;

// @public
export type FileSystemCopyFilesFilter = (sourcePath: string, destinationPath: string) => boolean;

// @public
export type FileSystemStats = fs.Stats;

// @public
export class FileWriter {
    close(): void;
    readonly filePath: string;
    static open(filePath: string, flags?: IFileWriterFlags): FileWriter;
    write(text: string): void;
}

// @public
export enum FolderConstants {
    Git = ".git",
    NodeModules = "node_modules"
}

// @public
export type FolderItem = fs.Dirent;

// @public
export interface IAnsiEscapeConvertForTestsOptions {
    encodeNewlines?: boolean;
}

// @beta
export interface IAsyncParallelismOptions {
    concurrency?: number;
}

// @beta (undocumented)
export interface IColorableSequence {
    // (undocumented)
    backgroundColor?: ColorValue;
    // (undocumented)
    foregroundColor?: ColorValue;
    // (undocumented)
    isEol?: boolean;
    // (undocumented)
    text: string;
    // (undocumented)
    textAttributes?: TextAttribute[];
}

// @beta
export interface IConsoleTerminalProviderOptions {
    debugEnabled: boolean;
    verboseEnabled: boolean;
}

// @public
export interface IEnvironmentEntry {
    name: string;
    value: string;
}

// @public
export interface IExecutableResolveOptions {
    currentWorkingDirectory?: string;
    environment?: NodeJS.ProcessEnv;
    environmentMap?: EnvironmentMap;
}

// @public
export interface IExecutableSpawnOptions extends IExecutableResolveOptions {
    stdio?: ExecutableStdioMapping;
}

// @public
export interface IExecutableSpawnSyncOptions extends IExecutableResolveOptions {
    input?: string;
    maxBuffer?: number;
    stdio?: ExecutableStdioMapping;
    timeoutMs?: number;
}

// @public
export interface IFileErrorFormattingOptions {
    format?: FileLocationStyle;
}

// @public
export interface IFileErrorOptions {
    absolutePath: string;
    column?: number;
    line?: number;
    projectFolder: string;
}

// @public (undocumented)
export interface IFileSystemCopyFileBaseOptions {
    alreadyExistsBehavior?: AlreadyExistsBehavior;
    sourcePath: string;
}

// @public
export interface IFileSystemCopyFileOptions extends IFileSystemCopyFileBaseOptions {
    destinationPath: string;
}

// @public
export interface IFileSystemCopyFilesAsyncOptions {
    alreadyExistsBehavior?: AlreadyExistsBehavior;
    dereferenceSymlinks?: boolean;
    destinationPath: string;
    filter?: FileSystemCopyFilesAsyncFilter | FileSystemCopyFilesFilter;
    preserveTimestamps?: boolean;
    sourcePath: string;
}

// @public
export interface IFileSystemCopyFilesOptions extends IFileSystemCopyFilesAsyncOptions {
    filter?: FileSystemCopyFilesFilter;
}

// @public
export interface IFileSystemCreateLinkOptions {
    alreadyExistsBehavior?: AlreadyExistsBehavior;
    linkTargetPath: string;
    newLinkPath: string;
}

// @public
export interface IFileSystemDeleteFileOptions {
    throwIfNotExists?: boolean;
}

// @public
export interface IFileSystemMoveOptions {
    destinationPath: string;
    ensureFolderExists?: boolean;
    overwrite?: boolean;
    sourcePath: string;
}

// @public
export interface IFileSystemReadFileOptions {
    convertLineEndings?: NewlineKind;
    encoding?: Encoding;
}

// @public
export interface IFileSystemReadFolderOptions {
    absolutePaths?: boolean;
}

// @public
export interface IFileSystemUpdateTimeParameters {
    accessedTime: number | Date;
    modifiedTime: number | Date;
}

// @public
export interface IFileSystemWriteFileOptions {
    convertLineEndings?: NewlineKind;
    encoding?: Encoding;
    ensureFolderExists?: boolean;
}

// @public
export interface IFileWriterFlags {
    append?: boolean;
    exclusive?: boolean;
}

// @public
export interface IImportResolveModuleOptions extends IImportResolveOptions {
    modulePath: string;
}

// @public
export interface IImportResolveOptions {
    allowSelfReference?: boolean;
    baseFolderPath: string;
    includeSystemModules?: boolean;
}

// @public
export interface IImportResolvePackageOptions extends IImportResolveOptions {
    packageName: string;
}

// @public
export interface IJsonFileSaveOptions extends IJsonFileStringifyOptions {
    ensureFolderExists?: boolean;
    onlyIfChanged?: boolean;
    updateExistingFile?: boolean;
}

// @public
export interface IJsonFileStringifyOptions {
    headerComment?: string;
    ignoreUndefinedValues?: boolean;
    newlineConversion?: NewlineKind;
    prettyFormatting?: boolean;
}

// @public
export interface IJsonSchemaErrorInfo {
    details: string;
}

// @public
export interface IJsonSchemaFromFileOptions {
    dependentSchemas?: JsonSchema[];
}

// @public
export interface IJsonSchemaValidateOptions {
    customErrorHeader?: string;
}

// @public
export class Import {
    static lazy(moduleName: string, require: (id: string) => unknown): any;
    static resolveModule(options: IImportResolveModuleOptions): string;
    static resolvePackage(options: IImportResolvePackageOptions): string;
}

// @public
export interface INodePackageJson {
    bin?: string;
    dependencies?: IPackageJsonDependencyTable;
    description?: string;
    devDependencies?: IPackageJsonDependencyTable;
    homepage?: string;
    license?: string;
    main?: string;
    name: string;
    optionalDependencies?: IPackageJsonDependencyTable;
    peerDependencies?: IPackageJsonDependencyTable;
    private?: boolean;
    repository?: string | IPackageJsonRepository;
    resolutions?: Record<string, string>;
    scripts?: IPackageJsonScriptTable;
    // @beta
    tsdocMetadata?: string;
    types?: string;
    typings?: string;
    version?: string;
}

// @public
export class InternalError extends Error {
    constructor(message: string);
    static breakInDebugger: boolean;
    // @override (undocumented)
    toString(): string;
    readonly unformattedMessage: string;
}

// @public
export interface IPackageJson extends INodePackageJson {
    version: string;
}

// @public
export interface IPackageJsonDependencyTable {
    [dependencyName: string]: string;
}

// @public
export interface IPackageJsonLookupParameters {
    loadExtraFields?: boolean;
}

// @public
export interface IPackageJsonRepository {
    directory?: string;
    type: string;
    url: string;
}

// @public
export interface IPackageJsonScriptTable {
    [scriptName: string]: string;
}

// @public
export interface IPackageNameParserOptions {
    allowUpperCase?: boolean;
}

// @public
export interface IParsedPackageName {
    scope: string;
    unscopedName: string;
}

// @public
export interface IParsedPackageNameOrError extends IParsedPackageName {
    error: string;
}

// @public
export interface IPathFormatConciselyOptions {
    baseFolder: string;
    pathToConvert: string;
    trimLeadingDotSlash?: boolean;
}

// @public
export interface IPathFormatFileLocationOptions {
    baseFolder?: string;
    column?: number;
    format: FileLocationStyle;
    line?: number;
    message: string;
    pathToFormat: string;
}

// @public
export interface IProtectableMapParameters<K, V> {
    onClear?: (source: ProtectableMap<K, V>) => void;
    onDelete?: (source: ProtectableMap<K, V>, key: K) => void;
    onSet?: (source: ProtectableMap<K, V>, key: K, value: V) => V;
}

// @beta (undocumented)
export interface IStringBufferOutputOptions {
    normalizeSpecialCharacters: boolean;
}

// @public
export interface IStringBuilder {
    append(text: string): void;
    toString(): string;
}

// @beta
export interface ISubprocessOptions {
    detached: boolean;
}

// @beta (undocumented)
export interface ITerminal {
    registerProvider(provider: ITerminalProvider): void;
    unregisterProvider(provider: ITerminalProvider): void;
    write(...messageParts: (string | IColorableSequence)[]): void;
    writeDebug(...messageParts: (string | IColorableSequence)[]): void;
    writeDebugLine(...messageParts: (string | IColorableSequence)[]): void;
    writeError(...messageParts: (string | IColorableSequence)[]): void;
    writeErrorLine(...messageParts: (string | IColorableSequence)[]): void;
    writeLine(...messageParts: (string | IColorableSequence)[]): void;
    writeVerbose(...messageParts: (string | IColorableSequence)[]): void;
    writeVerboseLine(...messageParts: (string | IColorableSequence)[]): void;
    writeWarning(...messageParts: (string | IColorableSequence)[]): void;
    writeWarningLine(...messageParts: (string | IColorableSequence)[]): void;
}

// @beta
export interface ITerminalProvider {
    eolCharacter: string;
    supportsColor: boolean;
    write(data: string, severity: TerminalProviderSeverity): void;
}

// @public
export class JsonFile {
    // @internal (undocumented)
    static _formatPathForError: (path: string) => string;
    static load(jsonFilename: string): JsonObject;
    static loadAndValidate(jsonFilename: string, jsonSchema: JsonSchema, options?: IJsonSchemaValidateOptions): JsonObject;
    static loadAndValidateAsync(jsonFilename: string, jsonSchema: JsonSchema, options?: IJsonSchemaValidateOptions): Promise<JsonObject>;
    static loadAndValidateWithCallback(jsonFilename: string, jsonSchema: JsonSchema, errorCallback: (errorInfo: IJsonSchemaErrorInfo) => void): JsonObject;
    static loadAndValidateWithCallbackAsync(jsonFilename: string, jsonSchema: JsonSchema, errorCallback: (errorInfo: IJsonSchemaErrorInfo) => void): Promise<JsonObject>;
    static loadAsync(jsonFilename: string): Promise<JsonObject>;
    static parseString(jsonContents: string): JsonObject;
    static save(jsonObject: JsonObject, jsonFilename: string, options?: IJsonFileSaveOptions): boolean;
    static saveAsync(jsonObject: JsonObject, jsonFilename: string, options?: IJsonFileSaveOptions): Promise<boolean>;
    static stringify(jsonObject: JsonObject, options?: IJsonFileStringifyOptions): string;
    static updateString(previousJson: string, newJsonObject: JsonObject, options?: IJsonFileStringifyOptions): string;
    static validateNoUndefinedMembers(jsonObject: JsonObject): void;
}

// @public
export type JsonNull = null;

// @public
export type JsonObject = any;

// @public
export class JsonSchema {
    ensureCompiled(): void;
    static fromFile(filename: string, options?: IJsonSchemaFromFileOptions): JsonSchema;
    static fromLoadedObject(schemaObject: JsonObject): JsonSchema;
    get shortName(): string;
    validateObject(jsonObject: JsonObject, filenameForErrors: string, options?: IJsonSchemaValidateOptions): void;
    validateObjectWithCallback(jsonObject: JsonObject, errorCallback: (errorInfo: IJsonSchemaErrorInfo) => void): void;
}

// @public
export class LegacyAdapters {
    static convertCallbackToPromise<TResult, TError>(fn: (cb: LegacyCallback<TResult, TError>) => void): Promise<TResult>;
    // (undocumented)
    static convertCallbackToPromise<TResult, TError, TArg1>(fn: (arg1: TArg1, cb: LegacyCallback<TResult, TError>) => void, arg1: TArg1): Promise<TResult>;
    // (undocumented)
    static convertCallbackToPromise<TResult, TError, TArg1, TArg2>(fn: (arg1: TArg1, arg2: TArg2, cb: LegacyCallback<TResult, TError>) => void, arg1: TArg1, arg2: TArg2): Promise<TResult>;
    // (undocumented)
    static convertCallbackToPromise<TResult, TError, TArg1, TArg2, TArg3>(fn: (arg1: TArg1, arg2: TArg2, arg3: TArg3, cb: LegacyCallback<TResult, TError>) => void, arg1: TArg1, arg2: TArg2, arg3: TArg3): Promise<TResult>;
    // (undocumented)
    static convertCallbackToPromise<TResult, TError, TArg1, TArg2, TArg3, TArg4>(fn: (arg1: TArg1, arg2: TArg2, arg3: TArg3, arg4: TArg4, cb: LegacyCallback<TResult, TError>) => void, arg1: TArg1, arg2: TArg2, arg3: TArg3, arg4: TArg4): Promise<TResult>;
    static scrubError(error: Error | string | any): Error;
    static sortStable<T>(array: T[], compare?: (a: T, b: T) => number): void;
}

// @public
export type LegacyCallback<TResult, TError> = (error: TError | null | undefined, result: TResult) => void;

// @public
export class LockFile {
    static acquire(resourceFolder: string, resourceName: string, maxWaitMs?: number): Promise<LockFile>;
    get dirtyWhenAcquired(): boolean;
    get filePath(): string;
    static getLockFilePath(resourceFolder: string, resourceName: string, pid?: number): string;
    get isReleased(): boolean;
    release(): void;
    static tryAcquire(resourceFolder: string, resourceName: string): LockFile | undefined;
}

// @public
export class MapExtensions {
    static mergeFromMap<K, V>(targetMap: Map<K, V>, sourceMap: ReadonlyMap<K, V>): void;
    static toObject<TValue>(map: Map<string, TValue>): {
        [key: string]: TValue;
    };
}

// @public
export enum NewlineKind {
    CrLf = "\r\n",
    Lf = "\n",
    OsDefault = "os"
}

// @public
export class PackageJsonLookup {
    constructor(parameters?: IPackageJsonLookupParameters);
    clearCache(): void;
    static get instance(): PackageJsonLookup;
    loadNodePackageJson(jsonFilename: string): INodePackageJson;
    static loadOwnPackageJson(dirnameOfCaller: string): IPackageJson;
    loadPackageJson(jsonFilename: string): IPackageJson;
    tryGetPackageFolderFor(fileOrFolderPath: string): string | undefined;
    tryGetPackageJsonFilePathFor(fileOrFolderPath: string): string | undefined;
    tryLoadNodePackageJsonFor(fileOrFolderPath: string): INodePackageJson | undefined;
    tryLoadPackageJsonFor(fileOrFolderPath: string): IPackageJson | undefined;
}

// @public
export class PackageName {
    static combineParts(scope: string, unscopedName: string): string;
    static getScope(packageName: string): string;
    static getUnscopedName(packageName: string): string;
    static isValidName(packageName: string): boolean;
    static parse(packageName: string): IParsedPackageName;
    static tryParse(packageName: string): IParsedPackageNameOrError;
    static validate(packageName: string): void;
}

// @public
export class PackageNameParser {
    constructor(options?: IPackageNameParserOptions);
    combineParts(scope: string, unscopedName: string): string;
    getScope(packageName: string): string;
    getUnscopedName(packageName: string): string;
    isValidName(packageName: string): boolean;
    parse(packageName: string): IParsedPackageName;
    tryParse(packageName: string): IParsedPackageNameOrError;
    validate(packageName: string): void;
}

// @public
export class Path {
    static convertToBackslashes(inputPath: string): string;
    static convertToSlashes(inputPath: string): string;
    static formatConcisely(options: IPathFormatConciselyOptions): string;
    static formatFileLocation(options: IPathFormatFileLocationOptions): string;
    static isDownwardRelative(inputPath: string): boolean;
    static isEqual(path1: string, path2: string): boolean;
    static isUnder(childPath: string, parentFolderPath: string): boolean;
    static isUnderOrEqual(childPath: string, parentFolderPath: string): boolean;
}

// @public
export enum PosixModeBits {
    AllExecute = 73,
    AllRead = 292,
    AllWrite = 146,
    GroupExecute = 8,
    GroupRead = 32,
    GroupWrite = 16,
    None = 0,
    OthersExecute = 1,
    OthersRead = 4,
    OthersWrite = 2,
    UserExecute = 64,
    UserRead = 256,
    UserWrite = 128
}

// @public
export class ProtectableMap<K, V> {
    constructor(parameters: IProtectableMapParameters<K, V>);
    clear(): void;
    delete(key: K): boolean;
    forEach(callbackfn: (value: V, key: K, map: Map<K, V>) => void, thisArg?: any): void;
    get(key: K): V | undefined;
    has(key: K): boolean;
    get protectedView(): Map<K, V>;
    set(key: K, value: V): this;
    get size(): number;
}

// @public
export class Sort {
    static compareByValue(x: any, y: any): number;
    static isSorted<T>(array: T[], comparer?: (x: any, y: any) => number): boolean;
    static isSortedBy<T>(array: T[], keySelector: (element: T) => any, comparer?: (x: any, y: any) => number): boolean;
    static sortBy<T>(array: T[], keySelector: (element: T) => any, comparer?: (x: any, y: any) => number): void;
    static sortMapKeys<K, V>(map: Map<K, V>, keyComparer?: (x: K, y: K) => number): void;
    static sortSet<T>(set: Set<T>, comparer?: (x: T, y: T) => number): void;
    static sortSetBy<T>(set: Set<T>, keySelector: (element: T) => any, keyComparer?: (x: T, y: T) => number): void;
}

// @beta
export class StringBufferTerminalProvider implements ITerminalProvider {
    constructor(supportsColor?: boolean);
    get eolCharacter(): string;
    getDebugOutput(options?: IStringBufferOutputOptions): string;
    getErrorOutput(options?: IStringBufferOutputOptions): string;
    getOutput(options?: IStringBufferOutputOptions): string;
    getVerbose(options?: IStringBufferOutputOptions): string;
    getWarningOutput(options?: IStringBufferOutputOptions): string;
    get supportsColor(): boolean;
    write(data: string, severity: TerminalProviderSeverity): void;
}

// @public
export class StringBuilder implements IStringBuilder {
    constructor();
    append(text: string): void;
    toString(): string;
}

// @beta
export class SubprocessTerminator {
    static killProcessTree(subprocess: child_process.ChildProcess, subprocessOptions: ISubprocessOptions): void;
    static killProcessTreeOnExit(subprocess: child_process.ChildProcess, subprocessOptions: ISubprocessOptions): void;
    static readonly RECOMMENDED_OPTIONS: ISubprocessOptions;
}

// @beta
export class Terminal implements ITerminal {
    constructor(provider: ITerminalProvider);
    registerProvider(provider: ITerminalProvider): void;
    unregisterProvider(provider: ITerminalProvider): void;
    write(...messageParts: (string | IColorableSequence)[]): void;
    writeDebug(...messageParts: (string | IColorableSequence)[]): void;
    writeDebugLine(...messageParts: (string | IColorableSequence)[]): void;
    writeError(...messageParts: (string | IColorableSequence)[]): void;
    writeErrorLine(...messageParts: (string | IColorableSequence)[]): void;
    writeLine(...messageParts: (string | IColorableSequence)[]): void;
    writeVerbose(...messageParts: (string | IColorableSequence)[]): void;
    writeVerboseLine(...messageParts: (string | IColorableSequence)[]): void;
    writeWarning(...messageParts: (string | IColorableSequence)[]): void;
    writeWarningLine(...messageParts: (string | IColorableSequence)[]): void;
}

// @beta
export enum TerminalProviderSeverity {
    // (undocumented)
    debug = 4,
    // (undocumented)
    error = 2,
    // (undocumented)
    log = 0,
    // (undocumented)
    verbose = 3,
    // (undocumented)
    warning = 1
}

// @public
export class Text {
    static convertTo(input: string, newlineKind: NewlineKind): string;
    static convertToCrLf(input: string): string;
    static convertToLf(input: string): string;
    static ensureTrailingNewline(s: string, newlineKind?: NewlineKind): string;
    static getNewline(newlineKind: NewlineKind): string;
    static padEnd(s: string, minimumLength: number, paddingCharacter?: string): string;
    static padStart(s: string, minimumLength: number, paddingCharacter?: string): string;
    static replaceAll(input: string, searchValue: string, replaceValue: string): string;
    static truncateWithEllipsis(s: string, maximumLength: number): string;
}

// @beta
export enum TextAttribute {
    // (undocumented)
    Blink = 3,
    // (undocumented)
    Bold = 0,
    // (undocumented)
    Dim = 1,
    // (undocumented)
    Hidden = 5,
    // (undocumented)
    InvertColor = 4,
    // (undocumented)
    Underline = 2
}

// @public
export class TypeUuid {
    static isInstanceOf(targetObject: unknown, typeUuid: string): boolean;
    static registerClass(targetClass: any, typeUuid: string): void;
}

```
