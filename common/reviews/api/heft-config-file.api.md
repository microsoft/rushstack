## API Report File for "@rushstack/heft-config-file"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { IRigConfig } from '@rushstack/rig-package';
import type { ITerminal } from '@rushstack/terminal';

// @beta @deprecated (undocumented)
export const ConfigurationFile: typeof ProjectConfigurationFile;

// @beta @deprecated (undocumented)
export type ConfigurationFile<TConfigurationFile> = ProjectConfigurationFile<TConfigurationFile>;

// @beta (undocumented)
export abstract class ConfigurationFileBase<TConfigurationFile, TExtraOptions extends {}> {
    constructor(options: IConfigurationFileOptions<TConfigurationFile, TExtraOptions>);
    // @internal (undocumented)
    static _formatPathForLogging: (path: string) => string;
    getObjectSourceFilePath<TObject extends object>(obj: TObject): string | undefined;
    getPropertyOriginalValue<TParentProperty extends object, TValue>(options: IOriginalValueOptions<TParentProperty>): TValue | undefined;
    getSchemaPropertyOriginalValue<TObject extends object>(obj: TObject): string | undefined;
    // (undocumented)
    protected _loadConfigurationFileInnerWithCache(terminal: ITerminal, resolvedConfigurationFilePath: string, projectFolderPath: string | undefined, onConfigurationFileNotFound?: IOnConfigurationFileNotFoundCallback): TConfigurationFile;
    // (undocumented)
    protected _loadConfigurationFileInnerWithCacheAsync(terminal: ITerminal, resolvedConfigurationFilePath: string, projectFolderPath: string | undefined, onFileNotFound?: IOnConfigurationFileNotFoundCallback): Promise<TConfigurationFile>;
}

// @beta
export type CustomValidationFunction<TConfigurationFile> = (configurationFile: TConfigurationFile, resolvedConfigurationFilePathForLogging: string, terminal: ITerminal) => boolean;

// @beta (undocumented)
export type IConfigurationFileOptions<TConfigurationFile, TExtraOptions extends object> = IConfigurationFileOptionsWithJsonSchemaFilePath<TConfigurationFile, TExtraOptions> | IConfigurationFileOptionsWithJsonSchemaObject<TConfigurationFile, TExtraOptions>;

// @beta (undocumented)
export interface IConfigurationFileOptionsBase<TConfigurationFile> {
    customValidationFunction?: CustomValidationFunction<TConfigurationFile>;
    jsonPathMetadata?: IJsonPathsMetadata<TConfigurationFile>;
    propertyInheritance?: IPropertiesInheritance<TConfigurationFile>;
    propertyInheritanceDefaults?: IPropertyInheritanceDefaults;
}

// @beta (undocumented)
export type IConfigurationFileOptionsWithJsonSchemaFilePath<TConfigurationFile, TExtraOptions extends {}> = IConfigurationFileOptionsBase<TConfigurationFile> & TExtraOptions & {
    jsonSchemaPath: string;
    jsonSchemaObject?: never;
};

// @beta (undocumented)
export type IConfigurationFileOptionsWithJsonSchemaObject<TConfigurationFile, TExtraOptions extends {}> = IConfigurationFileOptionsBase<TConfigurationFile> & TExtraOptions & {
    jsonSchemaObject: object;
    jsonSchemaPath?: never;
};

// @beta
export interface ICustomJsonPathMetadata<TConfigurationFile> {
    customResolver?: (resolverOptions: IJsonPathMetadataResolverOptions<TConfigurationFile>) => string;
    pathResolutionMethod?: PathResolutionMethod.custom;
}

// @beta (undocumented)
export interface ICustomPropertyInheritance<TObject> extends IPropertyInheritance<InheritanceType.custom> {
    inheritanceFunction: PropertyInheritanceCustomFunction<TObject>;
}

// @beta (undocumented)
export type IJsonPathMetadata<T> = ICustomJsonPathMetadata<T> | INonCustomJsonPathMetadata;

// @beta
export interface IJsonPathMetadataResolverOptions<TConfigurationFile> {
    configurationFile: Partial<TConfigurationFile>;
    configurationFilePath: string;
    projectFolderPath?: string;
    propertyName: string;
    propertyValue: string;
}

// @beta
export interface IJsonPathsMetadata<TConfigurationFile> {
    // (undocumented)
    [jsonPath: string]: IJsonPathMetadata<TConfigurationFile>;
}

// @beta
export const InheritanceType: {
    readonly append: "append";
    readonly merge: "merge";
    readonly replace: "replace";
    readonly custom: "custom";
};

// @beta (undocumented)
export type InheritanceType = (typeof InheritanceType)[keyof typeof InheritanceType];

// @beta (undocumented)
export namespace InheritanceType {
    export type append = typeof InheritanceType.append;
    export type custom = typeof InheritanceType.custom;
    export type merge = typeof InheritanceType.merge;
    export type replace = typeof InheritanceType.replace;
}

// @beta
export interface INonCustomJsonPathMetadata {
    pathResolutionMethod?: PathResolutionMethod.NodeResolve | PathResolutionMethod.nodeResolve | PathResolutionMethod.resolvePathRelativeToConfigurationFile | PathResolutionMethod.resolvePathRelativeToProjectRoot;
}

// @beta
export type IOnConfigurationFileNotFoundCallback = (resolvedConfigurationFilePathForLogging: string) => string | undefined;

// @beta (undocumented)
export interface IOriginalValueOptions<TParentProperty> {
    // (undocumented)
    parentObject: Partial<TParentProperty>;
    // (undocumented)
    propertyName: keyof TParentProperty;
}

// @beta (undocumented)
export interface IProjectConfigurationFileOptions {
    projectRelativeFilePath: string;
}

// @beta
export type IProjectConfigurationFileSpecification<TConfigFile> = IConfigurationFileOptions<TConfigFile, IProjectConfigurationFileOptions>;

// @beta (undocumented)
export type IPropertiesInheritance<TConfigurationFile> = {
    [propertyName in keyof TConfigurationFile]?: IPropertyInheritance<InheritanceType.append | InheritanceType.merge | InheritanceType.replace> | ICustomPropertyInheritance<TConfigurationFile[propertyName]>;
};

// @beta (undocumented)
export interface IPropertyInheritance<TInheritanceType extends InheritanceType> {
    // (undocumented)
    inheritanceType: TInheritanceType;
}

// @beta (undocumented)
export interface IPropertyInheritanceDefaults {
    // (undocumented)
    array?: IPropertyInheritance<InheritanceType.append | InheritanceType.replace>;
    // (undocumented)
    object?: IPropertyInheritance<InheritanceType.merge | InheritanceType.replace>;
}

// @beta (undocumented)
export class NonProjectConfigurationFile<TConfigurationFile> extends ConfigurationFileBase<TConfigurationFile, {}> {
    loadConfigurationFile(terminal: ITerminal, filePath: string): TConfigurationFile;
    loadConfigurationFileAsync(terminal: ITerminal, filePath: string): Promise<TConfigurationFile>;
    tryLoadConfigurationFile(terminal: ITerminal, filePath: string): TConfigurationFile | undefined;
    tryLoadConfigurationFileAsync(terminal: ITerminal, filePath: string): Promise<TConfigurationFile | undefined>;
}

// @beta
export const PathResolutionMethod: {
    readonly resolvePathRelativeToConfigurationFile: "resolvePathRelativeToConfigurationFile";
    readonly resolvePathRelativeToProjectRoot: "resolvePathRelativeToProjectRoot";
    readonly NodeResolve: "NodeResolve";
    readonly nodeResolve: "nodeResolve";
    readonly custom: "custom";
};

// @beta (undocumented)
export type PathResolutionMethod = (typeof PathResolutionMethod)[keyof typeof PathResolutionMethod];

// @beta (undocumented)
export namespace PathResolutionMethod {
    export type custom = typeof PathResolutionMethod.custom;
    // @deprecated
    export type NodeResolve = typeof PathResolutionMethod.NodeResolve;
    export type nodeResolve = typeof PathResolutionMethod.nodeResolve;
    export type resolvePathRelativeToConfigurationFile = typeof PathResolutionMethod.resolvePathRelativeToConfigurationFile;
    export type resolvePathRelativeToProjectRoot = typeof PathResolutionMethod.resolvePathRelativeToProjectRoot;
}

// @beta (undocumented)
export class ProjectConfigurationFile<TConfigurationFile> extends ConfigurationFileBase<TConfigurationFile, IProjectConfigurationFileOptions> {
    constructor(options: IProjectConfigurationFileSpecification<TConfigurationFile>);
    loadConfigurationFileForProject(terminal: ITerminal, projectPath: string, rigConfig?: IRigConfig): TConfigurationFile;
    loadConfigurationFileForProjectAsync(terminal: ITerminal, projectPath: string, rigConfig?: IRigConfig): Promise<TConfigurationFile>;
    readonly projectRelativeFilePath: string;
    tryLoadConfigurationFileForProject(terminal: ITerminal, projectPath: string, rigConfig?: IRigConfig): TConfigurationFile | undefined;
    tryLoadConfigurationFileForProjectAsync(terminal: ITerminal, projectPath: string, rigConfig?: IRigConfig): Promise<TConfigurationFile | undefined>;
}

// @beta (undocumented)
export type PropertyInheritanceCustomFunction<TObject> = (currentObject: TObject, parentObject: TObject) => TObject;

// @beta
function stripAnnotations<TObject>(obj: TObject): TObject;

declare namespace TestUtilities {
    export {
        stripAnnotations
    }
}

```
