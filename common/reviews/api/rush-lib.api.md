## API Report File for "@microsoft/rush-lib"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { AsyncParallelHook } from 'tapable';
import { AsyncSeriesHook } from 'tapable';
import { AsyncSeriesWaterfallHook } from 'tapable';
import type { CollatedWriter } from '@rushstack/stream-collator';
import type { CommandLineParameter } from '@rushstack/ts-command-line';
import { HookMap } from 'tapable';
import { IPackageJson } from '@rushstack/node-core-library';
import { ITerminal } from '@rushstack/node-core-library';
import { ITerminalProvider } from '@rushstack/node-core-library';
import { JsonObject } from '@rushstack/node-core-library';
import { PackageNameParser } from '@rushstack/node-core-library';
import type { StdioSummarizer } from '@rushstack/terminal';
import { SyncHook } from 'tapable';
import { Terminal } from '@rushstack/node-core-library';

// @public
export class ApprovedPackagesConfiguration {
    constructor(jsonFilename: string);
    // (undocumented)
    addOrUpdatePackage(packageName: string, reviewCategory: string): boolean;
    clear(): void;
    // (undocumented)
    getItemByName(packageName: string): ApprovedPackagesItem | undefined;
    // (undocumented)
    items: ApprovedPackagesItem[];
    loadFromFile(): void;
    saveToFile(): void;
    tryLoadFromFile(approvedPackagesPolicyEnabled: boolean): boolean;
}

// @public
export class ApprovedPackagesItem {
    // @internal
    constructor(packageName: string);
    allowedCategories: Set<string>;
    packageName: string;
}

// @public
export class ApprovedPackagesPolicy {
    // Warning: (ae-forgotten-export) The symbol "IRushConfigurationJson" needs to be exported by the entry point index.d.ts
    //
    // @internal
    constructor(rushConfiguration: RushConfiguration, rushConfigurationJson: IRushConfigurationJson);
    get browserApprovedPackages(): ApprovedPackagesConfiguration;
    get enabled(): boolean;
    get ignoredNpmScopes(): Set<string>;
    get nonbrowserApprovedPackages(): ApprovedPackagesConfiguration;
    get reviewCategories(): Set<string>;
}

// @beta
export class BuildCacheConfiguration {
    readonly buildCacheEnabled: boolean;
    cacheWriteEnabled: boolean;
    readonly cloudCacheProvider: ICloudBuildCacheProvider | undefined;
    static getBuildCacheConfigFilePath(rushConfiguration: RushConfiguration): string;
    readonly getCacheEntryId: GetCacheEntryIdFunction;
    static loadAndRequireEnabledAsync(terminal: ITerminal, rushConfiguration: RushConfiguration, rushSession: RushSession): Promise<BuildCacheConfiguration>;
    readonly localCacheProvider: FileSystemBuildCacheProvider;
    static tryLoadAsync(terminal: ITerminal, rushConfiguration: RushConfiguration, rushSession: RushSession): Promise<BuildCacheConfiguration | undefined>;
}

// @public
export enum BumpType {
    // (undocumented)
    'major' = 5,
    // (undocumented)
    'minor' = 4,
    // (undocumented)
    'none' = 0,
    // (undocumented)
    'patch' = 2,
    // (undocumented)
    'preminor' = 3,
    // (undocumented)
    'prerelease' = 1
}

// @public
export class ChangeManager {
    static createEmptyChangeFiles(rushConfiguration: RushConfiguration, projectName: string, emailAddress: string): string | undefined;
}

// Warning: (ae-forgotten-export) The symbol "IBuildCacheJson" needs to be exported by the entry point index.d.ts
//
// @beta (undocumented)
export type CloudBuildCacheProviderFactory = (buildCacheJson: IBuildCacheJson) => ICloudBuildCacheProvider;

// @public
export class CommonVersionsConfiguration {
    get allowedAlternativeVersions(): Map<string, ReadonlyArray<string>>;
    get filePath(): string;
    getAllPreferredVersions(): Map<string, string>;
    getPreferredVersionsHash(): string;
    get implicitlyPreferredVersions(): boolean | undefined;
    static loadFromFile(jsonFilename: string): CommonVersionsConfiguration;
    get preferredVersions(): Map<string, string>;
    save(): boolean;
}

// @beta (undocumented)
export class CredentialCache {
    // (undocumented)
    deleteCacheEntry(cacheId: string): void;
    // (undocumented)
    dispose(): void;
    // (undocumented)
    static initializeAsync(options: ICredentialCacheOptions): Promise<CredentialCache>;
    // (undocumented)
    saveIfModifiedAsync(): Promise<void>;
    // (undocumented)
    setCacheEntry(cacheId: string, credential: string, expires?: Date): void;
    // (undocumented)
    trimExpiredEntries(): void;
    // (undocumented)
    tryGetCacheEntry(cacheId: string): ICredentialCacheEntry | undefined;
    // (undocumented)
    static usingAsync(options: ICredentialCacheOptions, doActionAsync: (credentialCache: CredentialCache) => Promise<void> | void): Promise<void>;
}

// @public (undocumented)
export enum DependencyType {
    // (undocumented)
    Dev = "devDependencies",
    // (undocumented)
    Optional = "optionalDependencies",
    // (undocumented)
    Peer = "peerDependencies",
    // (undocumented)
    Regular = "dependencies",
    // (undocumented)
    YarnResolutions = "resolutions"
}

// @beta
export class EnvironmentConfiguration {
    static get absoluteSymlinks(): boolean;
    static get allowUnsupportedNodeVersion(): boolean;
    static get allowWarningsInSuccessfulBuild(): boolean;
    static get buildCacheCredential(): string | undefined;
    static get buildCacheEnabled(): boolean | undefined;
    static get buildCacheWriteAllowed(): boolean | undefined;
    // Warning: (ae-forgotten-export) The symbol "IEnvironment" needs to be exported by the entry point index.d.ts
    //
    // @internal
    static _getRushGlobalFolderOverride(processEnv: IEnvironment): string | undefined;
    static get gitBinaryPath(): string | undefined;
    // (undocumented)
    static parseBooleanEnvironmentVariable(name: string, value: string | undefined): boolean | undefined;
    static get pnpmStorePathOverride(): string | undefined;
    static reset(): void;
    static get rushGlobalFolderOverride(): string | undefined;
    static get rushTempFolderOverride(): string | undefined;
    static get tarBinaryPath(): string | undefined;
    static validate(options?: IEnvironmentConfigurationInitializeOptions): void;
}

// @beta
export enum EnvironmentVariableNames {
    RUSH_ABSOLUTE_SYMLINKS = "RUSH_ABSOLUTE_SYMLINKS",
    RUSH_ALLOW_UNSUPPORTED_NODEJS = "RUSH_ALLOW_UNSUPPORTED_NODEJS",
    RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD = "RUSH_ALLOW_WARNINGS_IN_SUCCESSFUL_BUILD",
    RUSH_BUILD_CACHE_CREDENTIAL = "RUSH_BUILD_CACHE_CREDENTIAL",
    RUSH_BUILD_CACHE_ENABLED = "RUSH_BUILD_CACHE_ENABLED",
    RUSH_BUILD_CACHE_WRITE_ALLOWED = "RUSH_BUILD_CACHE_WRITE_ALLOWED",
    RUSH_DEPLOY_TARGET_FOLDER = "RUSH_DEPLOY_TARGET_FOLDER",
    RUSH_GIT_BINARY_PATH = "RUSH_GIT_BINARY_PATH",
    RUSH_GLOBAL_FOLDER = "RUSH_GLOBAL_FOLDER",
    RUSH_INVOKED_FOLDER = "RUSH_INVOKED_FOLDER",
    RUSH_PARALLELISM = "RUSH_PARALLELISM",
    RUSH_PNPM_STORE_PATH = "RUSH_PNPM_STORE_PATH",
    RUSH_PREVIEW_VERSION = "RUSH_PREVIEW_VERSION",
    RUSH_TAR_BINARY_PATH = "RUSH_TAR_BINARY_PATH",
    RUSH_TEMP_FOLDER = "RUSH_TEMP_FOLDER",
    RUSH_VARIANT = "RUSH_VARIANT"
}

// @beta
export enum Event {
    postRushBuild = 4,
    postRushInstall = 2,
    preRushBuild = 3,
    preRushInstall = 1
}

// @beta
export class EventHooks {
    // Warning: (ae-forgotten-export) The symbol "IEventHooksJson" needs to be exported by the entry point index.d.ts
    //
    // @internal
    constructor(eventHooksJson: IEventHooksJson);
    get(event: Event): string[];
}

// @public
export class ExperimentsConfiguration {
    // @internal
    constructor(jsonFileName: string);
    // @beta
    get configuration(): Readonly<IExperimentsJson>;
}

// @beta
export class FileSystemBuildCacheProvider {
    constructor(options: IFileSystemBuildCacheProviderOptions);
    getCacheEntryPath(cacheId: string): string;
    tryGetCacheEntryPathByIdAsync(terminal: ITerminal, cacheId: string): Promise<string | undefined>;
    trySetCacheEntryBufferAsync(terminal: ITerminal, cacheId: string, entryBuffer: Buffer): Promise<string>;
}

// @beta
export type GetCacheEntryIdFunction = (options: IGenerateCacheEntryIdOptions) => string;

// @internal (undocumented)
export interface _IBuiltInPluginConfiguration extends _IRushPluginConfigurationBase {
    // (undocumented)
    pluginPackageFolder: string;
}

// @beta (undocumented)
export interface ICloudBuildCacheProvider {
    // (undocumented)
    deleteCachedCredentialsAsync(terminal: ITerminal): Promise<void>;
    // (undocumented)
    readonly isCacheWriteAllowed: boolean;
    // (undocumented)
    tryGetCacheEntryBufferByIdAsync(terminal: ITerminal, cacheId: string): Promise<Buffer | undefined>;
    // (undocumented)
    trySetCacheEntryBufferAsync(terminal: ITerminal, cacheId: string, entryBuffer: Buffer): Promise<boolean>;
    // (undocumented)
    updateCachedCredentialAsync(terminal: ITerminal, credential: string): Promise<void>;
    // (undocumented)
    updateCachedCredentialInteractiveAsync(terminal: ITerminal): Promise<void>;
}

// @public
export interface IConfigurationEnvironment {
    [environmentVariableName: string]: IConfigurationEnvironmentVariable;
}

// @public
export interface IConfigurationEnvironmentVariable {
    override?: boolean;
    value: string;
}

// @alpha
export interface ICreateOperationsContext {
    readonly buildCacheConfiguration: BuildCacheConfiguration | undefined;
    readonly customParameters: ReadonlyMap<string, CommandLineParameter>;
    readonly isIncrementalBuildAllowed: boolean;
    readonly isInitial: boolean;
    readonly isWatch: boolean;
    readonly phaseSelection: ReadonlySet<IPhase>;
    readonly projectChangeAnalyzer: ProjectChangeAnalyzer;
    readonly projectSelection: ReadonlySet<RushConfigurationProject>;
    readonly projectsInUnknownState: ReadonlySet<RushConfigurationProject>;
    readonly rushConfiguration: RushConfiguration;
}

// @beta (undocumented)
export interface ICredentialCacheEntry {
    // (undocumented)
    credential: string;
    // (undocumented)
    expires?: Date;
}

// @beta (undocumented)
export interface ICredentialCacheOptions {
    // (undocumented)
    supportEditing: boolean;
}

// @beta (undocumented)
export interface IEnvironmentConfigurationInitializeOptions {
    // (undocumented)
    doNotNormalizePaths?: boolean;
}

// @alpha
export interface IExecutionResult {
    readonly operationResults: ReadonlyMap<Operation, IOperationExecutionResult>;
    readonly status: OperationStatus;
}

// @beta
export interface IExperimentsJson {
    buildCacheWithAllowWarningsInSuccessfulBuild?: boolean;
    noChmodFieldInTarHeaderNormalization?: boolean;
    omitImportersFromPreventManualShrinkwrapChanges?: boolean;
    phasedCommands?: boolean;
    usePnpmFrozenLockfileForRushInstall?: boolean;
    usePnpmPreferFrozenLockfileForRushUpdate?: boolean;
}

// @beta
export interface IFileSystemBuildCacheProviderOptions {
    rushConfiguration: RushConfiguration;
    rushUserConfiguration: RushUserConfiguration;
}

// @beta
export interface IGenerateCacheEntryIdOptions {
    phaseName: string;
    projectName: string;
    projectStateHash: string;
}

// @beta (undocumented)
export interface IGetChangedProjectsOptions {
    enableFiltering: boolean;
    includeExternalDependencies: boolean;
    // (undocumented)
    shouldFetch?: boolean;
    // (undocumented)
    targetBranchName: string;
    // (undocumented)
    terminal: ITerminal;
}

// @beta
export interface IGlobalCommand extends IRushCommand {
}

// @public
export interface ILaunchOptions {
    alreadyReportedNodeTooNewError?: boolean;
    // @internal
    builtInPluginConfigurations?: _IBuiltInPluginConfiguration[];
    isManaged: boolean;
    terminalProvider?: ITerminalProvider;
}

// @beta (undocumented)
export interface ILogger {
    emitError(error: Error): void;
    emitWarning(warning: Error): void;
    // (undocumented)
    readonly terminal: Terminal;
}

// @public
export class IndividualVersionPolicy extends VersionPolicy {
    // Warning: (ae-forgotten-export) The symbol "IIndividualVersionJson" needs to be exported by the entry point index.d.ts
    //
    // @internal
    constructor(versionPolicyJson: IIndividualVersionJson);
    bump(bumpType?: BumpType, identifier?: string): void;
    ensure(project: IPackageJson, force?: boolean): IPackageJson | undefined;
    // @internal
    get _json(): IIndividualVersionJson;
    get lockedMajor(): number | undefined;
    validate(versionString: string, packageName: string): void;
}

// @internal
export interface _INpmOptionsJson extends IPackageManagerOptionsJsonBase {
}

// @alpha
export interface IOperationExecutionResult {
    readonly error: Error | undefined;
    readonly status: OperationStatus;
    readonly stdioSummarizer: StdioSummarizer;
    readonly stopwatch: IStopwatchResult;
}

// @alpha
export interface IOperationOptions {
    phase?: IPhase | undefined;
    project?: RushConfigurationProject | undefined;
    runner?: IOperationRunner | undefined;
}

// @beta
export interface IOperationRunner {
    executeAsync(context: IOperationRunnerContext): Promise<OperationStatus>;
    isCacheWriteAllowed: boolean;
    isSkipAllowed: boolean;
    readonly name: string;
    reportTiming: boolean;
    silent: boolean;
    warningsAreAllowed: boolean;
}

// @beta
export interface IOperationRunnerContext {
    collatedWriter: CollatedWriter;
    debugMode: boolean;
    quietMode: boolean;
    stdioSummarizer: StdioSummarizer;
}

// @public
export interface IPackageManagerOptionsJsonBase {
    environmentVariables?: IConfigurationEnvironment;
}

// @alpha
export interface IPhase {
    allowWarningsOnSuccess: boolean;
    associatedParameters: Set<CommandLineParameter>;
    dependencies: {
        self: Set<IPhase>;
        upstream: Set<IPhase>;
    };
    ignoreMissingScript: boolean;
    isSynthetic: boolean;
    logFilenameIdentifier: string;
    name: string;
}

// @beta
export interface IPhasedCommand extends IRushCommand {
    // @alpha
    readonly hooks: PhasedCommandHooks;
}

// @internal
export interface _IPnpmOptionsJson extends IPackageManagerOptionsJsonBase {
    pnpmStore?: PnpmStoreOptions;
    preventManualShrinkwrapChanges?: boolean;
    strictPeerDependencies?: boolean;
    useWorkspaces?: boolean;
}

// @beta
export interface IRushCommand {
    readonly actionName: string;
}

// @beta (undocumented)
export interface IRushPlugin {
    // (undocumented)
    apply(rushSession: RushSession, rushConfiguration: RushConfiguration): void;
}

// @internal (undocumented)
export interface _IRushPluginConfigurationBase {
    // (undocumented)
    packageName: string;
    // (undocumented)
    pluginName: string;
}

// @beta (undocumented)
export interface IRushSessionOptions {
    // (undocumented)
    getIsDebugMode: () => boolean;
    // (undocumented)
    terminalProvider: ITerminalProvider;
}

// @alpha
export interface IStopwatchResult {
    get duration(): number;
    get endTime(): number | undefined;
    get startTime(): number | undefined;
    toString(): string;
}

// @beta (undocumented)
export interface ITelemetryData {
    readonly durationInSeconds: number;
    // (undocumented)
    readonly extraData?: {
        [key: string]: string | number | boolean;
    };
    readonly name: string;
    readonly platform?: string;
    readonly result: 'Succeeded' | 'Failed';
    readonly rushVersion?: string;
    readonly timestamp?: number;
}

// @public
export interface ITryFindRushJsonLocationOptions {
    showVerbose?: boolean;
    startingFolder?: string;
}

// @internal
export interface _IYarnOptionsJson extends IPackageManagerOptionsJsonBase {
    ignoreEngines?: boolean;
}

// @internal
export class _LastInstallFlag {
    constructor(folderPath: string, state?: JsonObject);
    checkValidAndReportStoreIssues(): boolean;
    clear(): void;
    create(): void;
    protected get flagName(): string;
    isValid(): boolean;
    get path(): string;
}

// @public
export class LockStepVersionPolicy extends VersionPolicy {
    // Warning: (ae-forgotten-export) The symbol "ILockStepVersionJson" needs to be exported by the entry point index.d.ts
    //
    // @internal
    constructor(versionPolicyJson: ILockStepVersionJson);
    bump(bumpType?: BumpType, identifier?: string): void;
    ensure(project: IPackageJson, force?: boolean): IPackageJson | undefined;
    // @internal
    get _json(): ILockStepVersionJson;
    get mainProject(): string | undefined;
    get nextBump(): BumpType | undefined;
    update(newVersionString: string): boolean;
    validate(versionString: string, packageName: string): void;
    get version(): string;
}

// @beta
export class LookupByPath<TItem> {
    constructor(entries?: Iterable<[string, TItem]>, delimiter?: string);
    readonly delimiter: string;
    findChildPath(childPath: string): TItem | undefined;
    findChildPathFromSegments(childPathSegments: Iterable<string>): TItem | undefined;
    static iteratePathSegments(serializedPath: string, delimiter?: string): Iterable<string>;
    setItem(serializedPath: string, value: TItem): this;
    setItemFromSegments(pathSegments: Iterable<string>, value: TItem): this;
}

// @public
export class NpmOptionsConfiguration extends PackageManagerOptionsConfigurationBase {
    // @internal
    constructor(json: _INpmOptionsJson);
}

// @alpha
export class Operation {
    constructor(options?: IOperationOptions);
    addDependency(dependency: Operation): void;
    readonly associatedPhase: IPhase | undefined;
    readonly associatedProject: RushConfigurationProject | undefined;
    readonly consumers: ReadonlySet<Operation>;
    deleteDependency(dependency: Operation): void;
    readonly dependencies: ReadonlySet<Operation>;
    get name(): string | undefined;
    runner: IOperationRunner | undefined;
    weight: number;
}

// @beta
export enum OperationStatus {
    Blocked = "BLOCKED",
    Executing = "EXECUTING",
    Failure = "FAILURE",
    FromCache = "FROM CACHE",
    NoOp = "NO OP",
    Ready = "READY",
    Skipped = "SKIPPED",
    Success = "SUCCESS",
    SuccessWithWarning = "SUCCESS WITH WARNINGS"
}

// @public (undocumented)
export class PackageJsonDependency {
    constructor(name: string, version: string, type: DependencyType, onChange: () => void);
    // (undocumented)
    get dependencyType(): DependencyType;
    // (undocumented)
    get name(): string;
    // (undocumented)
    setVersion(newVersion: string): void;
    // (undocumented)
    get version(): string;
}

// @public (undocumented)
export class PackageJsonEditor {
    // (undocumented)
    addOrUpdateDependency(packageName: string, newVersion: string, dependencyType: DependencyType): void;
    get dependencyList(): ReadonlyArray<PackageJsonDependency>;
    get devDependencyList(): ReadonlyArray<PackageJsonDependency>;
    // (undocumented)
    get filePath(): string;
    // (undocumented)
    static fromObject(object: IPackageJson, filename: string): PackageJsonEditor;
    // (undocumented)
    static load(filePath: string): PackageJsonEditor;
    // (undocumented)
    get name(): string;
    get resolutionsList(): ReadonlyArray<PackageJsonDependency>;
    // (undocumented)
    saveIfModified(): boolean;
    saveToObject(): IPackageJson;
    // (undocumented)
    tryGetDependency(packageName: string): PackageJsonDependency | undefined;
    // (undocumented)
    tryGetDevDependency(packageName: string): PackageJsonDependency | undefined;
    // (undocumented)
    get version(): string;
}

// @public
export abstract class PackageManager {
    // @internal
    protected constructor(version: string, packageManager: PackageManagerName);
    readonly packageManager: PackageManagerName;
    get shrinkwrapFilename(): string;
    // (undocumented)
    protected _shrinkwrapFilename: string;
    readonly version: string;
}

// @public
export type PackageManagerName = 'pnpm' | 'npm' | 'yarn';

// @public
export abstract class PackageManagerOptionsConfigurationBase implements IPackageManagerOptionsJsonBase {
    // @internal
    protected constructor(json: IPackageManagerOptionsJsonBase);
    readonly environmentVariables?: IConfigurationEnvironment;
}

// @alpha
export class PhasedCommandHooks {
    readonly afterExecuteOperations: AsyncSeriesHook<[IExecutionResult, ICreateOperationsContext]>;
    readonly createOperations: AsyncSeriesWaterfallHook<[Set<Operation>, ICreateOperationsContext]>;
    readonly waitingForChanges: SyncHook<void>;
}

// @public
export class PnpmOptionsConfiguration extends PackageManagerOptionsConfigurationBase {
    // @internal
    constructor(json: _IPnpmOptionsJson, commonTempFolder: string);
    readonly pnpmStore: PnpmStoreOptions;
    readonly pnpmStorePath: string;
    readonly preventManualShrinkwrapChanges: boolean;
    readonly strictPeerDependencies: boolean;
    readonly useWorkspaces: boolean;
}

// @public
export type PnpmStoreOptions = 'local' | 'global';

// @beta (undocumented)
export class ProjectChangeAnalyzer {
    constructor(rushConfiguration: RushConfiguration);
    // Warning: (ae-forgotten-export) The symbol "IRawRepoState" needs to be exported by the entry point index.d.ts
    //
    // @internal (undocumented)
    _ensureInitialized(terminal: ITerminal): IRawRepoState | undefined;
    // (undocumented)
    _filterProjectDataAsync<T>(project: RushConfigurationProject, unfilteredProjectData: Map<string, T>, rootDir: string, terminal: ITerminal): Promise<Map<string, T>>;
    getChangedProjectsAsync(options: IGetChangedProjectsOptions): Promise<Set<RushConfigurationProject>>;
    // @internal
    _tryGetProjectDependenciesAsync(project: RushConfigurationProject, terminal: ITerminal): Promise<Map<string, string> | undefined>;
    // @internal
    _tryGetProjectStateHashAsync(project: RushConfigurationProject, terminal: ITerminal): Promise<string | undefined>;
}

// @public
export class RepoStateFile {
    get filePath(): string;
    get isValid(): boolean;
    static loadFromFile(jsonFilename: string, variant: string | undefined): RepoStateFile;
    get pnpmShrinkwrapHash(): string | undefined;
    get preferredVersionsHash(): string | undefined;
    refreshState(rushConfiguration: RushConfiguration): boolean;
}

// @public
export class Rush {
    static launch(launcherVersion: string, arg: ILaunchOptions): void;
    static launchRushPnpm(launcherVersion: string, options: ILaunchOptions): void;
    static launchRushX(launcherVersion: string, options: ILaunchOptions): void;
    static get version(): string;
}

// @public
export class RushConfiguration {
    get allowMostlyStandardPackageNames(): boolean;
    get approvedPackagesPolicy(): ApprovedPackagesPolicy;
    get changesFolder(): string;
    // @deprecated
    get committedShrinkwrapFilename(): string;
    get commonAutoinstallersFolder(): string;
    get commonFolder(): string;
    get commonRushConfigFolder(): string;
    get commonScriptsFolder(): string;
    get commonTempFolder(): string;
    // @deprecated
    get commonVersions(): CommonVersionsConfiguration;
    get currentInstalledVariant(): string | undefined;
    get currentVariantJsonFilename(): string;
    get ensureConsistentVersions(): boolean;
    // @beta
    get eventHooks(): EventHooks;
    // @beta
    get experimentsConfiguration(): ExperimentsConfiguration;
    findProjectByShorthandName(shorthandProjectName: string): RushConfigurationProject | undefined;
    findProjectByTempName(tempProjectName: string): RushConfigurationProject | undefined;
    getCommittedShrinkwrapFilename(variant?: string | undefined): string;
    getCommonVersions(variant?: string | undefined): CommonVersionsConfiguration;
    getCommonVersionsFilePath(variant?: string | undefined): string;
    getImplicitlyPreferredVersions(variant?: string | undefined): Map<string, string>;
    getPnpmfilePath(variant?: string | undefined): string;
    getProjectByName(projectName: string): RushConfigurationProject | undefined;
    // @beta (undocumented)
    getProjectLookupForRoot(rootPath: string): LookupByPath<RushConfigurationProject>;
    getRepoState(variant?: string | undefined): RepoStateFile;
    getRepoStateFilePath(variant?: string | undefined): string;
    get gitAllowedEmailRegExps(): string[];
    get gitChangeLogUpdateCommitMessage(): string | undefined;
    get gitSampleEmail(): string;
    get gitTagSeparator(): string | undefined;
    get gitVersionBumpCommitMessage(): string | undefined;
    get hotfixChangeEnabled(): boolean;
    static loadFromConfigurationFile(rushJsonFilename: string): RushConfiguration;
    // (undocumented)
    static loadFromDefaultLocation(options?: ITryFindRushJsonLocationOptions): RushConfiguration;
    get npmCacheFolder(): string;
    get npmOptions(): NpmOptionsConfiguration;
    get npmTmpFolder(): string;
    get packageManager(): PackageManagerName;
    get packageManagerOptions(): PackageManagerOptionsConfigurationBase;
    get packageManagerToolFilename(): string;
    get packageManagerToolVersion(): string;
    // @beta
    get packageManagerWrapper(): PackageManager;
    get packageNameParser(): PackageNameParser;
    get pnpmOptions(): PnpmOptionsConfiguration;
    get projectFolderMaxDepth(): number;
    get projectFolderMinDepth(): number;
    // (undocumented)
    get projects(): RushConfigurationProject[];
    // (undocumented)
    get projectsByName(): Map<string, RushConfigurationProject>;
    // @beta
    get projectsByTag(): ReadonlyMap<string, ReadonlySet<RushConfigurationProject>>;
    get repositoryDefaultBranch(): string;
    get repositoryDefaultFullyQualifiedRemoteBranch(): string;
    get repositoryDefaultRemote(): string;
    get repositoryUrls(): string[];
    // @internal
    get rushConfigurationJson(): IRushConfigurationJson;
    get rushJsonFile(): string;
    get rushJsonFolder(): string;
    // @deprecated
    get rushLinkJsonFilename(): string;
    get rushPluginOptionsFolder(): string;
    // Warning: (ae-forgotten-export) The symbol "RushPluginsConfiguration" needs to be exported by the entry point index.d.ts
    //
    // @internal (undocumented)
    get _rushPluginsConfiguration(): RushPluginsConfiguration;
    get shrinkwrapFilename(): string;
    get shrinkwrapFilePhrase(): string;
    get suppressNodeLtsWarning(): boolean;
    // @beta
    get telemetryEnabled(): boolean;
    get tempShrinkwrapFilename(): string;
    get tempShrinkwrapPreinstallFilename(): string;
    static tryFindRushJsonLocation(options?: ITryFindRushJsonLocationOptions): string | undefined;
    tryGetProjectForPath(currentFolderPath: string): RushConfigurationProject | undefined;
    // @beta (undocumented)
    get versionPolicyConfiguration(): VersionPolicyConfiguration;
    // @beta (undocumented)
    get versionPolicyConfigurationFilePath(): string;
    get yarnCacheFolder(): string;
    get yarnOptions(): YarnOptionsConfiguration;
}

// @public
export class RushConfigurationProject {
    // Warning: (ae-forgotten-export) The symbol "IRushConfigurationProjectOptions" needs to be exported by the entry point index.d.ts
    //
    // @internal
    constructor(options: IRushConfigurationProjectOptions);
    get consumingProjects(): ReadonlySet<RushConfigurationProject>;
    // @deprecated
    get cyclicDependencyProjects(): Set<string>;
    get decoupledLocalDependencies(): Set<string>;
    get dependencyProjects(): ReadonlySet<RushConfigurationProject>;
    // @deprecated
    get downstreamDependencyProjects(): string[];
    // @beta
    get isMainProject(): boolean;
    // @deprecated
    get localDependencyProjects(): ReadonlyArray<RushConfigurationProject>;
    get packageJson(): IPackageJson;
    // @beta
    get packageJsonEditor(): PackageJsonEditor;
    get packageName(): string;
    get projectFolder(): string;
    get projectRelativeFolder(): string;
    get projectRushConfigFolder(): string;
    get projectRushTempFolder(): string;
    get publishFolder(): string;
    get reviewCategory(): string | undefined;
    get rushConfiguration(): RushConfiguration;
    get shouldPublish(): boolean;
    get skipRushCheck(): boolean;
    // @beta
    get tags(): ReadonlySet<string>;
    get tempProjectName(): string;
    get unscopedTempProjectName(): string;
    // @beta
    get versionPolicy(): VersionPolicy | undefined;
    // @beta
    get versionPolicyName(): string | undefined;
}

// @beta
export class RushConstants {
    static readonly artifactoryFilename: string;
    static readonly browserApprovedPackagesFilename: string;
    static readonly buildCacheFilename: string;
    static readonly buildCacheVersion: number;
    static readonly buildCommandName: string;
    static readonly bulkCommandKind: 'bulk';
    static readonly changeFilesFolderName: string;
    static readonly commandLineFilename: string;
    static readonly commonFolderName: string;
    static readonly commonVersionsFilename: string;
    static readonly defaultMaxInstallAttempts: number;
    static readonly experimentsFilename: string;
    static readonly globalCommandKind: 'global';
    static readonly hashDelimiter: string;
    static readonly nodeModulesFolderName: string;
    static readonly nonbrowserApprovedPackagesFilename: string;
    static readonly npmShrinkwrapFilename: string;
    static readonly phasedCommandKind: 'phased';
    static readonly phaseNamePrefix: '_phase:';
    // @deprecated
    static readonly pinnedVersionsFilename: string;
    static readonly pnpmfileV1Filename: string;
    static readonly pnpmfileV6Filename: string;
    static readonly pnpmV3ShrinkwrapFilename: string;
    static readonly projectRushFolderName: string;
    static readonly projectShrinkwrapFilename: string;
    static readonly rebuildCommandName: string;
    static readonly repoStateFilename: string;
    static readonly rushLogsFolderName: string;
    static readonly rushPackageName: string;
    static readonly rushPluginManifestFilename: string;
    static readonly rushPluginsConfigFilename: string;
    static readonly rushProjectConfigFilename: string;
    static readonly rushRecyclerFolderName: string;
    static readonly rushTempFolderName: string;
    static readonly rushTempNpmScope: string;
    static readonly rushTempProjectsFolderName: string;
    static readonly rushUserConfigurationFolderName: string;
    static readonly rushVariantsFolderName: string;
    static readonly rushWebSiteUrl: string;
    // (undocumented)
    static readonly updateCloudCredentialsCommandName: string;
    // (undocumented)
    static readonly versionPoliciesFilename: string;
    static readonly yarnShrinkwrapFilename: string;
}

// @internal
export class _RushGlobalFolder {
    constructor();
    get nodeSpecificPath(): string;
    get path(): string;
}

// @beta
export class RushLifecycleHooks {
    flushTelemetry: AsyncParallelHook<[ReadonlyArray<ITelemetryData>]>;
    initialize: AsyncSeriesHook<IRushCommand>;
    runAnyGlobalCustomCommand: AsyncSeriesHook<IGlobalCommand>;
    runAnyPhasedCommand: AsyncSeriesHook<IPhasedCommand>;
    runGlobalCustomCommand: HookMap<AsyncSeriesHook<IGlobalCommand>>;
    runPhasedCommand: HookMap<AsyncSeriesHook<IPhasedCommand>>;
}

// @beta (undocumented)
export class RushSession {
    constructor(options: IRushSessionOptions);
    // (undocumented)
    getCloudBuildCacheProviderFactory(cacheProviderName: string): CloudBuildCacheProviderFactory | undefined;
    // (undocumented)
    getLogger(name: string): ILogger;
    // (undocumented)
    readonly hooks: RushLifecycleHooks;
    // (undocumented)
    registerCloudBuildCacheProviderFactory(cacheProviderName: string, factory: CloudBuildCacheProviderFactory): void;
    // (undocumented)
    get terminalProvider(): ITerminalProvider;
}

// @beta
export class RushUserConfiguration {
    readonly buildCacheFolder: string | undefined;
    // (undocumented)
    static getRushUserFolderPath(): string;
    // (undocumented)
    static initializeAsync(): Promise<RushUserConfiguration>;
}

// @public
export abstract class VersionPolicy {
    // Warning: (ae-forgotten-export) The symbol "IVersionPolicyJson" needs to be exported by the entry point index.d.ts
    //
    // @internal
    constructor(versionPolicyJson: IVersionPolicyJson);
    abstract bump(bumpType?: BumpType, identifier?: string): void;
    get definitionName(): VersionPolicyDefinitionName;
    abstract ensure(project: IPackageJson, force?: boolean): IPackageJson | undefined;
    get exemptFromRushChange(): boolean;
    get includeEmailInChangeFile(): boolean;
    get isLockstepped(): boolean;
    // @internal
    abstract get _json(): IVersionPolicyJson;
    // @internal
    static load(versionPolicyJson: IVersionPolicyJson): VersionPolicy | undefined;
    get policyName(): string;
    setDependenciesBeforeCommit(packageName: string, configuration: RushConfiguration): void;
    setDependenciesBeforePublish(packageName: string, configuration: RushConfiguration): void;
    abstract validate(versionString: string, packageName: string): void;
}

// @public
export class VersionPolicyConfiguration {
    // @internal
    constructor(jsonFileName: string);
    bump(versionPolicyName?: string, bumpType?: BumpType, identifier?: string, shouldCommit?: boolean): void;
    getVersionPolicy(policyName: string): VersionPolicy;
    update(versionPolicyName: string, newVersion: string, shouldCommit?: boolean): void;
    validate(projectsByName: Map<string, RushConfigurationProject>): void;
    get versionPolicies(): Map<string, VersionPolicy>;
}

// @public
export enum VersionPolicyDefinitionName {
    // (undocumented)
    'individualVersion' = 1,
    // (undocumented)
    'lockStepVersion' = 0
}

// @public
export class YarnOptionsConfiguration extends PackageManagerOptionsConfigurationBase {
    // @internal
    constructor(json: _IYarnOptionsJson);
    readonly ignoreEngines: boolean;
}

```
