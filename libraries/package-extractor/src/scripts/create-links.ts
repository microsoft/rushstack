// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.

// THIS SCRIPT IS GENERATED BY THE "rush deploy" COMMAND.

import os from 'node:os';
import fs from 'node:fs';
import path from 'node:path';
import { Async, FileSystem, Path } from '@rushstack/node-core-library';
import { Terminal, ConsoleTerminalProvider } from '@rushstack/terminal';
import type {
  TARGET_ROOT_SCRIPT_RELATIVE_PATH_TEMPLATE_STRING as TargetRootScriptRelativePathTemplateString,
  IExtractorMetadataJson
} from '../PackageExtractor';

const MAX_CONCURRENCY: number = os.cpus().length * 2;
const CREATE_ACTION_NAME: 'create' = 'create';
const REMOVE_ACTION_NAME: 'remove' = 'remove';
const REALIZE_FILES_OPTION_NAME: '--realize-files' = '--realize-files';

const TARGET_ROOT_SCRIPT_RELATIVE_PATH: typeof TargetRootScriptRelativePathTemplateString =
  '{TARGET_ROOT_SCRIPT_RELATIVE_PATH}';
const TARGET_ROOT_FOLDER: string = path.resolve(__dirname, TARGET_ROOT_SCRIPT_RELATIVE_PATH);

async function removeLinksAsync(
  terminal: Terminal,
  targetRootFolder: string,
  extractorMetadataObject: IExtractorMetadataJson
): Promise<void> {
  await Async.forEachAsync(
    extractorMetadataObject.links,
    async ({ linkPath }) => {
      const newLinkPath: string = `${targetRootFolder}/${linkPath}`;
      terminal.writeVerboseLine(`Removing link at path "${newLinkPath}"`);
      await FileSystem.deleteFileAsync(newLinkPath, { throwIfNotExists: false });
    },
    { concurrency: MAX_CONCURRENCY }
  );
}

async function createLinksAsync(
  terminal: Terminal,
  targetRootFolder: string,
  extractorMetadataObject: IExtractorMetadataJson
): Promise<void> {
  await Async.forEachAsync(
    extractorMetadataObject.links,
    async (linkInfo) => {
      // Link to the relative path for symlinks
      const newLinkPath: string = `${targetRootFolder}/${linkInfo.linkPath}`;
      const linkTargetPath: string = `${targetRootFolder}/${linkInfo.targetPath}`;

      // Make sure the containing folder exists
      await FileSystem.ensureFolderAsync(path.dirname(newLinkPath));

      // NOTE: This logic is based on NpmLinkManager._createSymlink()
      if (linkInfo.kind === 'folderLink') {
        terminal.writeVerboseLine(`Creating linked folder at path "${newLinkPath}"`);
        await FileSystem.createSymbolicLinkJunctionAsync({ newLinkPath, linkTargetPath });
      } else if (linkInfo.kind === 'fileLink') {
        // Use hardlinks for Windows and symlinks for other platforms since creating a symbolic link
        // requires administrator permission on Windows. This may cause unexpected behaviour for consumers
        // of the hardlinked files. If this becomes an issue, we may need to revisit this.
        terminal.writeVerboseLine(`Creating linked file at path "${newLinkPath}"`);
        if (process.platform === 'win32') {
          await FileSystem.createHardLinkAsync({ newLinkPath, linkTargetPath });
        } else {
          await FileSystem.createSymbolicLinkFileAsync({ newLinkPath, linkTargetPath });
        }
      }
    },
    { concurrency: MAX_CONCURRENCY }
  );
}

async function realizeFilesAsync(
  terminal: Terminal,
  targetRootFolder: string,
  extractorMetadataObject: IExtractorMetadataJson
): Promise<void> {
  await Async.forEachAsync(
    extractorMetadataObject.files,
    async (relativeFilePath) => {
      const filePath: string = `${targetRootFolder}/${relativeFilePath}`;
      const realFilePath: string = await FileSystem.getRealPathAsync(filePath);
      if (!Path.isEqual(realFilePath, filePath)) {
        await FileSystem.deleteFileAsync(filePath);

        // Hard links seem to cause build failures on Mac, so for all other operating
        // systems we copy files.
        terminal.writeVerboseLine(`Realizing file at path "${filePath}"`);
        if (process.platform === 'win32') {
          await FileSystem.createHardLinkAsync({ newLinkPath: filePath, linkTargetPath: realFilePath });
        } else {
          await FileSystem.copyFileAsync({ sourcePath: realFilePath, destinationPath: filePath });
        }
      }
    },
    { concurrency: MAX_CONCURRENCY }
  );
}

function showUsage(terminal: Terminal): void {
  terminal.writeLine('Usage:');
  terminal.writeLine(`  node create-links.js ${CREATE_ACTION_NAME} [${REALIZE_FILES_OPTION_NAME}]`);
  terminal.writeLine(`  node create-links.js ${REMOVE_ACTION_NAME}`);
  terminal.writeLine('');
  terminal.writeLine('Creates or removes the symlinks for the output folder created by "rush deploy".');
  terminal.writeLine('The link information is read from "extractor-metadata.json" in the same folder.');
}

async function runAsync(terminal: Terminal): Promise<boolean> {
  // Example: [ "node.exe", "create-links.js", ""create" ]
  const args: string[] = process.argv.slice(2);
  if (
    (args[0] !== CREATE_ACTION_NAME && args[0] !== REMOVE_ACTION_NAME) ||
    (args[0] === CREATE_ACTION_NAME && args[1] && args[1] !== REALIZE_FILES_OPTION_NAME) ||
    (args[0] === REMOVE_ACTION_NAME && args[1])
  ) {
    showUsage(terminal);
    return false;
  }

  const extractorMetadataPath: string = `${__dirname}/extractor-metadata.json`;
  if (!fs.existsSync(extractorMetadataPath)) {
    throw new Error('Input file not found: ' + extractorMetadataPath);
  }

  const extractorMetadataJson: string = fs.readFileSync(extractorMetadataPath).toString();
  const extractorMetadataObject: IExtractorMetadataJson = JSON.parse(extractorMetadataJson);

  if (args[0] === 'create') {
    const realizeFiles: boolean = args[1] === '--realize-files';
    terminal.writeLine(`Creating links for extraction at path "${TARGET_ROOT_FOLDER}"`);
    await removeLinksAsync(terminal, TARGET_ROOT_FOLDER, extractorMetadataObject);
    await createLinksAsync(terminal, TARGET_ROOT_FOLDER, extractorMetadataObject);
    if (realizeFiles) {
      await realizeFilesAsync(terminal, TARGET_ROOT_FOLDER, extractorMetadataObject);
    }
  } else if (args[0] === 'remove') {
    terminal.writeLine(`Removing links for extraction at path "${TARGET_ROOT_FOLDER}"`);
    await removeLinksAsync(terminal, TARGET_ROOT_FOLDER, extractorMetadataObject);
  }

  terminal.writeLine('The operation completed successfully.');
  return true;
}

process.exitCode = 1;
const terminal: Terminal = new Terminal(new ConsoleTerminalProvider());
runAsync(terminal)
  .then((result) => {
    process.exitCode = result ? 0 : 1;
  })
  .catch((error) => {
    terminal.writeErrorLine('ERROR: ' + error);
  });
